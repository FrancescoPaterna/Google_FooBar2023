{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import itertools\n",
    "\n",
    "#bellmanford algorithm\n",
    "def bellmanford(m,lm):\n",
    "    \n",
    "        dst = lm-1\n",
    "        src = 0\n",
    "        prices = [float(\"inf\")] * lm\n",
    "        prices[src] = 0\n",
    "\n",
    "        \n",
    "        for i in range(0,lm):\n",
    "            tmpPrices = list(prices)\n",
    "            \n",
    "            for s in range(0,lm):\n",
    "                for d in range(0,lm):\n",
    "                    if prices[s] == float(\"inf\") or s == d:\n",
    "                        continue\n",
    "                    if prices[s] + m[s][d] < tmpPrices[d]:\n",
    "                        tmpPrices[d] = prices[s] + m[s][d]\n",
    "            \n",
    "\n",
    "            if prices != tmpPrices:\n",
    "                #negative cycle case \n",
    "                if i == dst:\n",
    "                    return 'False'\n",
    "                #update current_best_path\n",
    "                else:\n",
    "                    prices = tmpPrices\n",
    "\n",
    "            else:\n",
    "                #end of bellmanford\n",
    "                return prices[dst]\n",
    "\n",
    "#generate path from a permutation             \n",
    "def path_generator(perm):\n",
    "    perm = list(perm)\n",
    "    perm = [0] + perm + [-1]\n",
    "    path = list()\n",
    "    for i in range(1, len(perm)):\n",
    "        path.append((perm[i-1], perm[i]))\n",
    "    return path\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def solution(times, time_limit):\n",
    "    \n",
    "    #Avoid bad input traps\n",
    "    if time_limit > 999 or time_limit < 0:\n",
    "        return []\n",
    "    \n",
    "    lm = len(times)\n",
    "    dst = lm-1\n",
    "    bunnies = lm -2\n",
    "    \n",
    "    #no bunnies to save :(\n",
    "    if lm < 3:\n",
    "        return []\n",
    "    \n",
    "    ##########################################################\n",
    "    #BELLMAN FORD SCREENING\n",
    "    \n",
    "    #run bellman-ford algorithm\n",
    "    res_bell = bellmanford(times,lm)\n",
    "    \n",
    "    #no escape case\n",
    "    if res_bell == float(\"inf\"):\n",
    "        return []\n",
    "    \n",
    "    #negative cycle case\n",
    "    elif res_bell == 'False':\n",
    "        return [0,1,2,3,4][0:dst-1]\n",
    "\n",
    "    #no enough time to escape case\n",
    "    if res_bell > time_limit:\n",
    "        return []\n",
    "        \n",
    "    ##########################################################\n",
    "    # Update times cell with the shortest way to reach position\n",
    "    # Floyd-Warshall Algorithm\n",
    "    \n",
    "    for k in range(lm):\n",
    "        for i in range(lm):\n",
    "            for j in range(lm):\n",
    "                if times[i][j] > times[i][k] + times[k][j]:\n",
    "                    times[i][j] = times[i][k] + times[k][j]\n",
    "    \n",
    "    \n",
    "    ##########################################################\n",
    "    # SEE ALL POSSIBLE PATH\n",
    "    \n",
    "    #trying all the combination of bunnies from the largest\n",
    "    #to the smallest\n",
    "    for i in reversed(range(lm)):\n",
    "        for perm in itertools.permutations(range(1,bunnies+1),i):\n",
    "            current_time = 0\n",
    "            #generate all the paths\n",
    "            path = path_generator(perm)\n",
    "            for s,e in path:\n",
    "                #check if the time respect the time limit\n",
    "                current_time += times[s][e]\n",
    "                #if respects the time limit, return the bunnies\n",
    "            if current_time <= time_limit:\n",
    "                sol = list(perm)\n",
    "                sol.sort()\n",
    "                for i in range(len(sol)):\n",
    "                    sol[i] -= 1\n",
    "                return sol\n",
    "\n",
    "    ##########################################################\n",
    "    \n",
    "    #no bunnies :(\n",
    "    return []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
